require "benzo"

class AR
	attr_accessor :args
	def initialize(minsup=10,confidence=80)
		@args = {}
		@args["-tr"] = true
		@args["-s" + minsup.to_s] = true if minsup != nil
		@args["-c" + confidence.to_s] = true if minsup != nil
		@args["-v\",%3S,%3C\""] = true
		#@args["-y"] = true
		#@args["-q1"] = true
		#@args["-z"] = true
		#@args["-p10"] = true
	end

	def generate_association_rules(infile, outfile)
		@args[infile] = true
		@args[outfile] = true
		puts ""
		puts "apriori " + @args.keys.join(" ")
		line = Benzo.line("apriori", @args)
		begin
			line.run
		rescue Cocaine::CommandNotFoundError => e
			e
			puts "'apriori' executable is not found in PATH."
		end

		# once outfile is generated by apriori binary, we need to 
		# parse the output and prune out the antecedents which are
		# not valid class labels. 
		labels = extract_class_labels(infile)

		# prune out rules which doesn't contain antecedents and rules
		# without valid class labels
		pruned_rules = prune_association_rules(outfile, labels)

		# sort rules in descending order of confidence
		sorted_rules = pruned_rules.sort {|a,b| b["confidence"].to_f <=> a["confidence"].to_f}
	end

	private
	def extract_class_labels(infile)
		classlabels = {}
		File.open(infile, "r").each_line do |line|
			# last field is the valid class label
			classlabels[line.split(" ").last.chomp] = 0
		end

		# we will return hashmap as labels lookup while pruning will be faster
		classlabels
	end

	private
	def prune_association_rules(outfile, labels)
		validrules = []
		actualsize = 0
		File.open(outfile, "r").each_line do |line|
			line.chomp!
			actualsize = actualsize + 1

			# check if the antecendent is a valid label or not
			if labels.has_key?(line.split("<-").first.strip) == true
				tokens = line.split(",")
				rules = {}

				# ignore rules that do not have antecedents
				if tokens[0].strip.end_with?("<-") != true
					rules["rule"] = tokens[0]
					rules["support"] = tokens[1]
					rules["confidence"] = tokens[2]
					validrules.push(rules)
				end
			end
		end

		puts "Total number of rules from " + outfile + ": " + actualsize.to_s
		puts "Total valid rules: " + validrules.size.to_s
		validrules
	end

	public
	def classify_based_on_association(rules, testing_set)
		default_class = get_default_class_label(rules)
		puts "\nDefault class label: " + default_class
		output = []
		File.open(testing_set, "r").each_line do |line|
			line.chomp!
			outline = {}
			fv = line.split(" ")
			classlabel = nil
			rules.each do |item|
				rule = item["rule"]
				antecedent = rule.split("<-").last.strip
				antecedents = antecedent.split(" ")

				# if antecedents are completely contained within the 
				# feature vector then we can assign the consequent as 
				# the class label else we will assign default class label
				if (antecedents-fv).empty? == true
					classlabel = rule.split("<-").first.strip
					break
				end
			end

			if classlabel != nil
				outline["contents"] = fv
				outline["topics"] = classlabel
			else
				outline["contents"] = fv
				outline["topics"] = default_class
			end

			output.push(outline)
		end

		output
	end

	# the default class label will be the maximum occuring consequent
	private 
	def get_default_class_label(rules)
		classcount = Hash.new(0)
		rules.each do |item|
			consequent = item["rule"].split("<-").first.strip
			if classcount[consequent] == 0
				classcount[consequent] = 1
			else
				classcount[consequent] = classcount[consequent] + 1
			end
		end

		# sort descending by value and return the key
		classcount.sort_by{|k,v| -v}.first[0]
	end

	# apriori software requires the input file be space separated values.
	# this function converts the csv bag of words to space separated string.
	# it also appends the class label to the end of each trnasaction. class
	# labels with "unknown" string are ignored in training set and also it
	# considers only the first class label in case of multi-class labels 
	public
	def get_training_set(td_format)
		output = []
		td_format.each do |item|
			if item["topics"] != "unknown" and item["topics"].empty? == false
				line = item["contents"].split(",")
				firstTopic = item["topics"].split(",").at(0)
				line.push(firstTopic)
				# join the items of transaction as a space separated string
				output.push(line.join(" "))
			end
		end

		output
	end

	public
	def get_testing_set(td_format)
		output = []
		td_format.each do |item|
			if item["topics"] == "unknown" or item["topics"].empty? == true
				line = item["contents"].split(",")
				# we do not want to save the unknown class label
				# join the items of transaction as a space separated string
				output.push(line.join(" "))
			end
		end

		output
	end
end